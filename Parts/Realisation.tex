\chapter{Simulation et Réalisation}
\section{Conception du logiciel}
\subsection{Description détaillée de la conception du logiciel}
\subsubsection{Architecture logicielle}
Ce système (SRI) est un système orienté WEB utilisant l'architecture MVC ou Modèle Vue Controlleur. C'est un motif d'architecture logicielle destiné aux interfaces graphiques, lancé en 1978 et très populaire pour les applications web \citep{mvcwiki}.

Cet architecture est illustré dans la Figure~\ref{fig:mvc}

\begin{figure}[htbp]
    \begin{center}
        \fbox{\includegraphics[width=13cm, angle=0]{Figures/Realisation/mvc.png}}
    \end{center}
    \caption{Architecture MVC \citep{mvcwiki}}\label{fig:mvc}
\end{figure}

\subsubsubsection*{Le Modèle (Model)}
Le Modèle contient les données a afficher a l'utilisateur. En d'autre terme, c'est la representation de la base de données. Dans le cadre de ce système, l'index inversé, les documents ainsi que les catégorie des documents sont representé par un modèle chacun.

\subsubsubsection*{La Vue (View)}
Elle contient la representation graphique, tel que les formulaires, les listes, les tables, etc. Elle est généralement ecrite en langage HTML pour une application WEB\@. Elle represente la formulaire de recherche, ainsi que les différenes filtres de recherche par l'utilisateur, et aussi les parties concernant l'authentification et d'autres.

\subsubsubsection*{Le Controlleur (Controller)}
Il contient la logique concernant les actions effectuées par l'utilisateur. En d'autre terme, il est le chef d'orchestre du système, traite les informations provenant de l'utilisateur et les persister dans la base de données et de recuperer des données et de les afficher a l'utilisateur. Dans ce système, il est responsable de tous traitement de documents, authentification, et d'autres traitements comme le telechargement et protection des documents.

Il est utilisé par de nombreux frameworks pour applications web tels que Ruby on Rails, Grails, ASP.NET MVC, Spring, Struts, Symfony, Apache Tapestry, Laravel, AdonisJS, Django ou AngularJS\@.

\subsubsection{Choix de conception clés}
Pour ce système, on distingue deux type de conception tel que la \emph{conception de la base de données} et la \emph{conception de l'interface utilisateur}. Pour la base de données, deux approche sont possible tel que \emph{MERISE} et \emph{UML}. L'une de grande différence entre MERISE et UML ce que MERISE traite les données et les traitements séparement tandis que UML non.

\subsubsubsection*{MERISE}
Merise est une méthode informatique dédiée à la modélisation qui analyse la structure à informatiser en terme de systèmes. Le gros avantage de cette méthode est qu’elle permet de cadrer le projet informatique et de \emph{discuter} en se comprenant entre utilisateurs et informaticiens \citep*{base-de-donnees}.

Créée dans les années 70 sur commande de l’État français et destinée aux gros projets informatiques de l’époque, la méthode a perduré jusqu’à aujourd’hui. Son utilisation très répandue en Europe constitue un socle difficilement contournable lorsque l’on s’attache à la création de bases de données.

Merise est en fait un outil analytique qui facilite la création de base de données et de projets informatique. Le principal auteur de la méthode est Hubert Tardieu qui se basa sur les travaux autour du modèle relationnel de Codd.

Elle permet réelement de:
\begin{itemize}
    \item décrire le fonctionnement du système à informatiser tel que les \textbf{données} representé par le MCD (Modèle Conceptuel de Données) qui determine les relations et les dépendances entres les différents acteurs (utilisateur, administrateur, documents), et les \emph{traitements} representé par le MCT (Modèle Conceptuel de Traitement) qui determine comment les acteurs travaillent-ils ensemble.
    \item proposer une implémentation logique tel que MLD (Modèle Logique de Données), MLT (Modèle Logique de Traitement).
    \item Proposer une construction concrète et utilisable du point précédent tel que la MPD (Modèle Physique de Donnée).
\end{itemize}

\subsubsubsection*{UML}
Le Langage de Modélisation Unifié, de l'anglais Unified Modeling Language, est un langage de modélisation graphique à base de pictogrammes conçu comme une méthode normalisée de visualisation dans les domaines du développement logiciel et en conception orientée objet. L'UML est une synthèse de langages de modélisation objet antérieurs: Booch, OMT, OOSE \citep*{UMLorg}.

Principalement issu des travaux de Grady Booch, James Rumbaugh et Ivar Jacobson, UML est à présent un standard adopté par l'Object Management Group. UML 1.0 a été normalisé en janvier 1997; UML 2.0 a été adopté par l'OMG en juillet 2005.

UML propose différentes diagrammes, et principalement catégorisé en trois catégories:
Bien sûr, voici une explication détaillée de chaque catégorie de diagrammes UML :

\begin{enumerate}
    \item \textbf{Structure}: Où on trouve
    \begin{itemize}
        \item \emph{Diagramme de classes}: Il montre la structure statique d'un système en mettant l'accent sur les classes du système, leurs attributs, leurs opérations et les relations entre les classes.
        \item \emph{Diagramme d'objets}: Il illustre des exemples spécifiques d'objets et de relations entre ces objets, montrant une instance particulière d'un diagramme de classes à un moment donné.
        \item \emph{Diagramme de composants}: Il met l'accent sur les composants d'un système logiciel et leurs dépendances, en montrant la structure des composants et la manière dont ils interagissent au niveau de l'architecture.
        \item \emph{Diagramme de paquetages}: Il organise les éléments d'un modèle en groupes, montrant comment ces éléments sont regroupés en paquets et les relations entre les paquets.
    \end{itemize}
    \item Comportément
    \begin{itemize}
        \item Diagramme de cas d'utilisation: Il décrit les interactions entre les utilisateurs et un système donné, mettant l'accent sur les fonctionnalités offertes par le système du point de vue de l'utilisateur.
        \item Diagramme de séquence: Il montre l'interaction entre les objets, en mettant l'accent sur la séquence temporelle des messages échangés entre les objets lors de l'exécution d'un scénario particulier.
        \item Diagramme d'activités: Il représente le flux de contrôle d'une activité ou d'un processus, mettant l'accent sur les actions et les décisions qui composent le processus.
        \item Diagramme d'états-transitions: Il modélise les transitions d'états pour un objet ou une entité donnée, montrant comment l'objet réagit aux événements au fil du temps.
    \end{itemize}
    \item Déploiement
    \begin{itemize}
        \item Diagramme de déploiement: Il montre la configuration matérielle d'un système et la manière dont les composants logiciels sont déployés sur cette configuration matérielle.
    \end{itemize}
\end{enumerate}

Ces différentes catégories de diagrammes UML offrent des moyens visuels efficaces pour modéliser les différents aspects d'un système logiciel, ce qui facilite la compréhension et la communication entre les différentes parties prenantes impliquées dans le processus de développement logiciel.

Dans le cadre de ce dévoir, on utilisera l'approche UML, vu qu'on utilise une architecture MVC et une approche orienté objet (OOP), cette approche sera plus bénéfique. Mais il est possible et ce sera envisageable d'utiliser Merise pour ce système.

Pour la conception de l'interface utilisateur, le langage de balisage HTML5, le feulle de style CSS3 ainsi que le langage JavaScript est utilisé.

\subsubsubsection*{SGBD}
Un SGBD ou Système de Gestion de Base de Données est un logiciel système permettant aux utilisateurs et programmeurs de créer et de gérer des bases de données. Plus précisement, il permet a un ordinateur de stocker, récupérer,
ajouter, supprimer et modifier des données. Ce système est aujourd’hui utilisé dans presque tous les outils que nous utilisons \citep*{oracleDB}.

Le SGBD gère trois choses importantes: les \emph{données}, le \emph{moteur de base de données} qui permet d'accéder aux données, de les verrouiller et de les modifier, et le \emph{schéma de base de données}, qui définit la structure logique de la base de données. Ces trois éléments fondamentaux contribuent à assurer la concomitance, la sécurité, l'intégrité des données et l'uniformité des procédures administratives \citep*{oracleDB}.

\subsubsection{Les fonctionnalités de base}
Citons les fonctionnalités de base qui sont le plus importants pour ce système.
\begin{enumerate}
    \item \textbf{Indexer des documents}: capacité d'indexer des documents textuelles de différente format tel que PDF, WORD et peut être des images donténant des textes. Cette fonctionnalité inclus l'extraction automatique de titre, resumé, date de soutenance, ainsi de faire un traitement de langage naturel. Cette donctionnalité se fait par un upload de fichier dans un navigateur WEB\@.
    \item \textbf{Système d'authentification}: permet a l'utilisateur de s'authentifier ou se créer des comptes afin de deposer et telecharger des documents. Elle permet aussi aux amdinistrateurs de valider des documents, les supprimer si necessaire. Elle permet aussi de disposer d'un espace membre en tant qu'étudiant et en tant qu'enseignant, verouller des documents et de ne donner l'accès qu'a certains utilisateurs.
    \item \textbf{Recherche par mots clés}: ette fonctionnalité permet aux utilisateurs de faire des recherches en utilisant une zone de saisie par des mots clés afin de satisfaire ses besoins. Cette fonctionnalité inclus d'autres fonctionnalités tel que le \emph{système de filtre de recherche}: recherche par conténu, par titre ou par auteur; \emph{système de filtre d'organisation}: par année croissante ou décroissante, par université; \emph{traitement de la reqête}: suppréssion des mots vides, correction des orthographes, pondération du terme de la requête. Elle se charge de faire l'appariément entre la requête de l'utilisateur et les documents dans la collection, et afficher ensuite les résultats par ordre de pertinence décroissante. L'utilisateur peut avoir une suggestion des mots clés lorsqu'il exprime son besoin d'information.
    \item \textbf{Page de resultat et visualisation de document}: permet d'afficher les resultats avec des paginations, ainsi que la possibilité de visualiser le resumé ou la partie du document. Il est aussi possible de visualiser un document en entier.
\end{enumerate}

\subsubsection{Les fonctionnalités de base en diagrammes}
Diagramme de cas d'utilisation, sequence et classe

\subsection{Technologies et outils utilisés}
\subsubsection{Technologies}
Pour develloper ce SRI, on a utilisé des téchnologies orientés vers l'intelligence artificiel implementé dans un application web. On aura utilisé une base de données pour stocker les données tel que les documents, les informations de l'utilisateur, etc. Ci-dessous la liste des téchnologies utilisés pour la réalisation de ce système.

\begin{itemize}
    \item \textbf{Framework Django}: est un framework web developpé en langage Python tilisant l'architecture MVT (Model-View-Template). A bien noter que dans Django, View est l'equivalent d'un Controlleur et que Template est l'equivalent de Vue. Ce choix est dû au fait qu'il est facile d'integré des librairies d'intelligence artificiel dans ce framework, ainsi que les fonctionnalités pré-concus facilitera beaucoup le devellopement \citep*{django}.
    \item \textbf{MySQL}: pour stocker les données comme on a dit ci-dessus. Elle est gratuite et largement suffisant pour ce genre de système en terme de capacité de stockage et en terme de rapidité de récuperation des données \citep*{mysql}.
    \item \textbf{Spacy}: est un librairy python permettant de faire un traitement de langage naturel. Il utilise un modèle de machine learning pré-entrainé pour différentes langages. Comme pour la langue française tel que le modèle \emph{\texttt{fr\_core\_web\_news\_sm}}, \emph{\texttt{fr\_core\_web\_news\_md}} et \emph{\texttt{fr\_core\_web\_news\_lg}}. Ce librairie permet de segmenter des textes en français, supprimer les mots vides, et recupérer la racine des mots, c'est ce librairie qui se charge de l'indexation dans ce SRI \citep*{spacy}.
    \item \textbf{NLTK}: ou Natural Language Toolkit est aussi ule librairie de traitement de langage naturel. Il permet aussi d'utiliser la base de connaissance tel que \emph{WordNet} pour trouver des synonymes des mots \citep*{nltk}.
    \item \textbf{Numpy}: est un librairie open source pour les calculs scientifiques avec python. Il est rapide et performant pour une vectorisation et calcul matriciel de N dimension \citep*{numpy}.
    \item \textbf{ScikitLearn}: est une bibliothèque logicielle libre d'apprentissage automatique pour le langage de programmation Python. Elle propose divers algorithmes de classification, de régression et de regroupement, notamment des machines à vecteurs de support (SVM), des forêts aléatoires (Random Forest), du boosting de gradient (Gradient boosting), des k-moyennes et DBSCAN, et est conçue pour interagir avec les bibliothèques numériques et scientifiques Python, NumPy et SciPy \citep*{scikit-learn}.
    \item \textbf{PDFPlumber}: est une librairie permettant d'extraire les informations detaillés pour chaque texte, rectangle, ligne et des tables dans un document pdf \citep*{pdfplumber}.
    \item \textbf{PyMuPDF}: PyMuPDF est une bibliothèque Python très performant pour l'extraction de données, l'analyse, la conversion et la manipulation de documents PDF et d'autres documents \citep*{fitz}. Dans le cadre de ce système, cette librairie se charge d'extraire les conténus des documents PDF\@.
    \item \textbf{Spellchecker library}: Pure Python Spell est utilisé pour corriger des fautes d'orthographes. Elle utilise l'algorithme de \emph{distance de Levenshtein} pour determiner le vrai mot \citep*{spellchecker}. Dans le cadre de ce système, cette librairie se charge de corriger la faute d'orthographe dans les mots clés de l'utilisateur qui composent son requête.
\end{itemize}

\subsubsection{Langage de programmation}
Diverses langages de programmation sont utilisés dans le cadre de ce système. Pour la programmation de base (Côté serveur), on a utilisé le langage de programmation \textbf{Python} par sa facilité d'intéragir avec les librairies de Machine Learning (ML) et du Deep Learning (DL). Python est un langage open source, multiplateforme, specialisé dans le domaine de l'intelligence artificiel et de l'analyse de données \citep{python}.

Pour la partie interface utilisateur, le langage HTML, CSS et JavaScript sont utilisés. Et le langage SQL pour le langage de requête a la base de données.

\subsubsection{Outils}
Diverses outils sont utilisés dans le cadre de ce système:

\begin{itemize}
    \item \textbf{Environnement de Developpement Integré (IDE)}: on a utilisé \emph{Visual Studio Code}, qui est un outils crée par Microsoft, OpenSource, gratuit et propose des diverses extensions pour faciliter le devellopement (compréhension du langage python par exemple) \citep*{vscode}.
    \item \textbf{Gestion de version}: \emph{Git} et \emph{Github} sont l'un de plus populaire pour mieux organiser les versions d'un système et propose système de travail en équipe \citep*{git, github}
    \item \textbf{Ordinateur utilisé}: ce système est realisé avec un ordinateur de processeur \textbf{Pentium G3200 @ 3300 Ghz}, avec \textbf{8GB de RAM}, et une \textbf{carte graphique Intel Graphic HD 4800} sous un système d'exploitation \textbf{KALI Linux 2022.3}.
    \item \textbf{Outil de test}: l'outil de test est integré directement dans le framework Django.
\end{itemize}

\section{Développement du logiciel}
\subsection{Etapes du processus de développement}
\subsubsection{Planification}
L'identification des donctionnalités se fait par l'analyse des moteurs de recherche existants pour determiner les fonctionnalités interressantes ainsi que de trouver les fonctionnalités manquantes et des lacunes. Une fois la liste des fonctionnalités necessaires determinés, l'identification des acteurs du système est mis en place. Une fois terminé, la modélisation de ces informations est faite en utilisant les diagrammes proposé par l'approche UML\@.

\subsubsection{Programmation}
D'abord, le système de securité est mis en place pour pouvoir deposer des documents, y compris la creation de compte, authentification ainsi que la mise en place de certains contraintes pour les utilisaeurs. Ensuite, la fonctionnalité d'indexation des documents, y comprys la création des index inversés, et tous les traitements rattachés a l'étape d'indexation (normalisation, stemmatisation). Ainsi le developpement de la partie recherche ou l'utilisateur peut recuperer la liste des documents qui repondent a son besoin, y compris la page de resultat. Et après la gestion des téléchargement des documents, gestion d'apercu es documents. Enfin la fonctionnalité de gestion du système par l'administrateur comme supprésion des documents, des utilisateurs, modification des droits d'accès.

Illustrons quelques algorithmes pour le fonctionnement de ce système.
Algorithme de Processus de recherche, indexation des documents

\begin{algorithm}
    \caption{Mise à jour des Vecteurs TF-IDF}
    \begin{algorithmic}[1]
        \State Récupérer tous les index inversés de la base de données.
        \State Prétraiter les termes extraits de chaque index inversé.
        \State Initialiser un vecteuriseur TF-IDF et l'ajuster sur les termes obtenus.
        \State Récupérer toutes les valeurs TF-IDF de la base de données.
        \State Extraire les identifiants de document de chaque valeur TF-IDF.
        \For{chaque identifiant de document}
            \State Récupérer le contenu du document correspondant à l'identifiant.
            \State Transformer le contenu en un vecteur TF-IDF en utilisant le vecteuriseur.
            \State Arrondir les valeurs du vecteur à quatre décimales.
            \State Convertir le vecteur en format JSON.
            \State Mettre à jour la valeur TF-IDF correspondante avec le nouveau vecteur.
        \EndFor
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}
    \caption{Mise à jour des Vecteurs TF-IDF}
    \begin{algorithmic}[1]
    \State \textbf{Données :} Indexes Inversés, Valeurs TF-IDF, Documents
    \State \textbf{Résultat :} Mise à jour des Vecteurs TF-IDF
    
    \State \textbf{Récupérer tous les index inversés :}
    \State inverted\_indexes $\leftarrow$ Index.objects.all()
    \State terms $\leftarrow$ [inverted\_index.term \textbf{pour} inverted\_index \textbf{dans} inverted\_indexes]
    \State terms $\leftarrow$ [preprocess\_text(term) \textbf{pour} term \textbf{dans} terms]
    
    \State \textbf{Initialiser un vecteuriseur TF-IDF :}
    \State vectorizer $\leftarrow$ TfidfVectorizer()
    \State vectorizer.fit\_transform(terms)
    
    \State \textbf{Récupérer toutes les valeurs TF-IDF de la base de données :}
    \State tfidf\_values $\leftarrow$ TfidfValues.objects.all()
    \State doc\_ids $\leftarrow$ [tfidf\_value.document\_id\_id \textbf{pour} tfidf\_value \textbf{dans} tfidf\_values]
    
    \For{chaque doc\_id \textbf{dans} doc\_ids}
        \State document\_terms $\leftarrow$ Documents.objects.get(pk=doc\_id).content.split()
        \State document\_vector $\leftarrow$ vectorizer.transform([" ".join(document\_terms)]).toarray()[0]
        
        \State document\_vector $\leftarrow$ np.round(document\_vector, 4)
        \State document\_vector\_json $\leftarrow$ json.dumps(document\_vector.tolist()) \textbf{  // Convertir en JSON}
        
        \State tfidf\_value $\leftarrow$ TfidfValues.objects.get(document\_id=doc\_id)
        \State tfidf\_value.tfidf\_vectors $\leftarrow$ document\_vector\_json
        \State tfidf\_value.save()
    \EndFor
    \end{algorithmic}
    \end{algorithm}
    
    \begin{algorithm}
    \caption{Algorithme de Traitement de Document}
    \begin{algorithmic}[1]
    \State \textbf{Données :} Requête HTTP
    \State \textbf{Résultat :} Redirection de l'utilisateur ou rendu du formulaire de téléchargement
    
    \State \textbf{Entrée :} request : HttpRequest
    \State \textbf{Sortie :} Redirection de l'utilisateur ou rendu du formulaire de téléchargement
    
    \State Assurez-vous que l'utilisateur est connecté
    
    \If{La méthode de la requête est 'POST'}
        \State Extraire le titre, l'auteur et la catégorie du document de la requête
        \State Vérifier l'existence du fichier et le sauvegarder si nécessaire
        
        \State Extraire le contenu textuel et le résumé du fichier
        \State Diviser le contenu en jetons individuels
        \State Convertir les jetons en vecteurs numériques
        
        \State Sauvegarder le document et les données associées
        \State Mettre à jour l'index inversé pour chaque terme
        \State Mettre à jour les vecteurs TF-IDF
        
        \State Rediriger l'utilisateur vers la page de téléchargement
    \Else
        \State Rendre le formulaire de téléchargement avec les catégories disponibles
    \EndIf
    \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}
        \caption{Gérer le Fichier Téléchargé}
        \begin{algorithmic}[1]
        \Function{handle\_uploaded\_file}{$f, dossier$}
            \State \textbf{Ouvrir} $destination$ \textbf{en mode} "wb+" \textbf{comme} $destination$
            \For{\textbf{chaque} $chunk$ \textbf{dans} $f.chunks()$}
                \State $destination.write(chunk)$
            \EndFor
        \EndFunction
        \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}
        \caption{Gérer le Fichier Téléchargé}
        \begin{algorithmic}[1]
        \Procedure{handle\_uploaded\_file}{$f, dossier$}
            \State Ouvrir le fichier de destination en mode écriture binaire.
            \For{chaque morceau de données dans les morceaux du fichier}
                \State Écrire le morceau de données dans le fichier de destination.
            \EndFor
        \EndProcedure
        \end{algorithmic}
    \end{algorithm}


    \begin{algorithm}
        \caption{Indexer la Requête}
        \begin{algorithmic}[1]
        \Procedure{index}{$request: HttpRequest$}
            \State {\# Page de recherche et traite l'appariément requête-documents \#}
            \State
            \State \textbf{Arguments:}
            \State $request$: La requête contenant les mots clés de l'utilisateur
            \State
            \State \textbf{Renvoie:}
            \State $HttpResponse$: La page de recherche ou la page de résultats de recherche
            \State
            \If{("query" dans $request.GET$)}
                \State $query \gets request.GET['query']$
            \Else
                \State $query \gets ""$
            \EndIf
            \State
            \If{("filter" dans $request.GET$)}
                \State $filter\_field \gets request.GET['filter']$
            \Else
                \State $filter\_field \gets "content"$
            \EndIf
            \State
            \If{($query \neq ""$)}
                \State $start \gets maintenant()$
                \State $end \gets None$
                \State $documents \gets []$
                \State
                \State $inverted\_indexes \gets Index.objects.all()$
                \State
                \If{($inverted\_indexes.count() > 0$)}
                    \State $terms \gets [inverted\_index.term$ \textbf{pour} $inverted\_index$ \textbf{dans} $inverted\_indexes]$
                    \State $terms \gets [preprocess\_text(term)$ \textbf{pour} $term$ \textbf{dans} $terms]$
                    \State
                    \State $vectorizer \gets TfidfVectorizer()$
                    \State $vectorizer.fit\_transform(terms)$
                    \State
                    \State $correct\_query\_terms \gets []$
                    \State $query\_terms \gets tokenize(query)$
                    \State
                    \For{$term$ \textbf{dans} $query\_terms$}
                        \State $correct\_term \gets correct\_word(term)$
                        \If{$correct\_term$ est \textbf{None}}
                            \State $correct\_query\_terms$.append($term$)
                        \Else
                            \State $correct\_query\_terms$.append($correct\_term$)
                        \EndIf
                    \EndFor
                    \State
                    \State $query\_terms \gets correct\_query\_terms$
                    \State $query\_vector \gets vectorizer.transform([" ".join(query\_terms)]).toarray()[0]$
                    \State
                    \If{($filter\_field == "content"$)}
                        \State $selected\_docs \gets search(query\_terms=query\_terms, query\_vector=query\_vector)$
                        \If{($len(selected\_docs) > 0$)}
                            \State $documents \gets Documents.findByIdsWithScore(ids = selected\_docs)$
                        \EndIf
                    \EndIf
                    \State
                    \If{($filter\_field == "title"$)}
                        \State $selected\_docs \gets searchBy(query\_terms=query\_terms, query\_vector=query\_vector, field="title")$
                        \If{($len(selected\_docs) > 0$)}
                            \State $documents \gets Documents.findByIdsWithScore(ids = selected\_docs)$
                        \EndIf
                    \EndIf
                    \State
                    \If{($filter\_field == "author"$)}
                        \State $query\_terms \gets query.split()$
                        \State $selected\_docs \gets searchBy(query\_terms=query\_terms, query\_vector=query\_vector, field="author")$
                        \If{($len(selected\_docs) > 0$)}
                            \State $documents \gets Documents.findByIdsWithScore(ids = selected\_docs)$
                        \EndIf
                    \EndIf
                \Else
                    \State \textbf{pass}
                \EndIf
                \State
                \State $documents$.extend($documents$)
                \State $documents$.extend($documents$)
                \State $documents$.extend($documents$)
                \State $documents$.extend($documents$)
                \State $documents$.extend($documents$)
                \State
                \If{('page' dans $request.GET$)}
                    \State $page\_number \gets request.GET['page']$
                \Else
                    \State $page\_number \gets 1$
                \EndIf
                \State
                \If{('perpage' dans $request.GET$)}
                    \State $per\_page \gets request.GET['perpage']$
                \Else
                    \State $per\_page \gets 5$
                \EndIf
                \State
                \State $paginator \gets Paginator(object\_list=documents, per\_page=per\_page)$
                \State $page\_obj \gets paginator.get\_page(number=page\_number)$
                \State
                \State $end \gets maintenant()$
                \State $response\_time \gets (end - start).total\_seconds()$
                \State
                \State \textbf{Renvoyer} $render(request=request, template\_name="client/results.html", context=\{... \})$
            \Else
                \If{($request.session.has\_key('query')$)}
                    \State $request.session.pop('query')$
                \EndIf
                \State
                \State \textbf{Renvoyer} $render(request=request, template\_name="client/index.html", context=\{... \})$
            \EndIf
        \EndProcedure
        \end{algorithmic}
    \end{algorithm}
        
% \subsubsection{Tests}

\subsection{Défis rencontrés lors du developpement}
Certains contraintes téchniques sont rencontrés, dont l'une le plus critique c'est que MySQL est plutott lent en terme d'insertion des données volumineux, car pour un document d'environ 80 pages, on aura environ 1000 à 2000 index. Ce qui entraine le ralentissement du système, car il faut environ 30seconde ou mçeme une minute pour indexer un document. Mais ce problème a été solutionné par l'utilisation des transaction. Une autre problème etait au niveau de choix de technologies a utiliser et des librairies.

% \section{Tests et validation du logiciel}
% \subsection{Stratégies de test utilisées pour évaluer la performance et la fonctionnalité du logiciel}
% \subsubsection{Tests unitaires}
% Description des tests unitaires réalisés pour vérifier le bon fonctionnement des composants individuels du logiciel.
% 
% \subsubsection{Tests d'intégration}
% Présentation des tests d'intégration effectués pour évaluer l'interopérabilité des différents modules du logiciel.
% 
% \subsubsection{Tests de validation}
% Explication des tests de validation effectués pour vérifier si le logiciel répond aux exigences spécifiées dans le cahier des charges.
% 
% \subsection{Résultats des tests et analyse critique des performances du logiciel}
% \subsubsection{Résultats des tests}
% Présentation des résultats détaillés des tests effectués, y compris les rapports de tests, les captures d'écran et les données de performance.
% 
% \subsubsection{Identification des problèmes}
% Discussion sur les éventuels problèmes ou erreurs identifiés au cours des tests, avec analyse critique des mesures prises pour corriger ces problèmes.

\section{Implémentation du logiciel dans un contexte réel}
\subsection{Processus d'implémentation}
Pour implementer ce logiciel, il faut des thèses et mémoires malagasy (Master, Doctorat, Article, Révue scientifique) pour alimenter la bae de données. Puis catégoriser ces documents afin de faciliter l'indexation de ces documents. Une fois ces documents indexés, le système est fonctionnel.

\subsection{Évaluation de l'efficacité de l'implémentation}
Analyse de l'efficacité de l'implémentation du logiciel en fonction des objectifs initiaux et des résultats observés dans le contexte réel.

\subsection{Rétroaction des utilisateurs}
Présentation des retours d'expérience et des commentaires des utilisateurs finaux concernant l'utilisation et les performances du logiciel dans leur environnement réel.

\subsection{Réponses aux problèmes éventuels}
Discussion sur la manière dont les problèmes éventuels rencontrés lors de l'implémentation ont été résolus, et sur les ajustements apportés pour améliorer l'expérience utilisateur et les performances du logiciel.

\section{Évaluation des performances et des résultats}
\subsection{Évaluation critique des performances du logiciel}
Analyse approfondie des performances du logiciel en termes de fonctionnalité, de convivialité, de fiabilité et d'efficacité, en se référant aux critères établis au début du projet.

\subsection{Comparaison avec les objectifs initiaux}
Comparaison des performances réelles du logiciel avec les objectifs initiaux définis lors de la conception, en mettant en évidence les écarts éventuels et les facteurs contributifs.

\subsection{Identification des forces et des faiblesses}
Identification des points forts et des limitations du logiciel en fonction des retours d'expérience des utilisateurs et des évaluations techniques, en mettant l'accent sur les domaines nécessitant d'éventuelles améliorations ou ajustements.

\subsection{Implications et recommandations}
Catégorisation des documents automatiques, extraction automatiques des titres, resumés, liste des bibbliographies, auteur, date de soutenance, encadreur ainsi que les membres de jury. Recupération des articles connexte. Création de bibliographie en connaissant ces informations.

% \section{Réflexions sur l'expérience de développement}
% \subsection{Analyse critique des leçons apprises}
% Analyse réfléchie des principaux enseignements tirés de l'expérience de développement du logiciel, en mettant l'accent sur les succès, les défis et les stratégies d'adaptation ou d'amélioration.
% 
% \subsection{Évaluation de l'efficacité des stratégies de développement}
% Évaluation de l'efficacité des différentes stratégies de développement utilisées tout au long du processus, en mettant en évidence les approches qui ont bien fonctionné et celles qui auraient pu être améliorées.
% 
% \subsection{Suggestions pour des améliorations futures}
% Proposition de suggestions concrètes pour améliorer les processus de développement, les stratégies de gestion de projet et les approches techniques pour de futurs projets similaires.
% 
% \subsection{Perspectives de recherche future}
% Discussion sur les pistes de recherche future potentielles basées sur les lacunes identifiées dans le cadre du projet actuel, en mettant l'accent sur les domaines qui méritent une exploration plus approfondie et des développements ultérieurs.